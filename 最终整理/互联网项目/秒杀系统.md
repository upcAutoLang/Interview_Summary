# 秒杀系统设计

> 参考地址：
> 
> [《《我们一起进大厂》系列-秒杀系统设计》](https://juejin.im/post/6844903999083151374)  
> [《秒杀系统架构分析与实战》](https://my.oschina.net/xianggao/blog/524943)  
> [《实战高并发秒杀实现（1）：理论研究》](https://blog.csdn.net/RuiKe1400360107/article/details/104721248)  
> [《实战高并发秒杀实现（2）：防止库存超卖问题（超详细）》](https://blog.csdn.net/RuiKe1400360107/article/details/104731775)  
> [《实战高并发秒杀实现（3）：基于Token令牌桶+MQ实现修改库存》](https://blog.csdn.net/RuiKe1400360107/article/details/104738575)  
> [《实战高并发秒杀实现（4）：基于责任链设模式的网关实现限流》](https://blog.csdn.net/RuiKe1400360107/article/details/104740859)  

# 一. 遇到问题

1. 前端问题：
	- 突然提升的并发量，导致的带宽激增；
	- 用户的重复提交；
	- 秒杀开始时间的统一；
2. 后端问题：
	- 超卖；
	- 高并发下的扣减库存；
	- 防止用户恶意攻击的作弊行为，限制用户操作频率；
	- 链接暴露；
	- 降级、限流、熔断

# 二. 解决问题思路

## 2.1 前端层面

**前端带宽激增**：

秒杀开始时的并发量非常大，假设商品页面大小 200K（主要是商品图片大小），那么需要的网络和服务器带宽是 2G (200K×10000)，这些网络带宽是因为秒杀活动新增的，超过网站平时使用的带宽。  
可以采用**动静分离**的解决方案：因为秒杀新增的网络带宽，必须和运营商重新购买或者租借。为了减轻网站服务器的压力，需要将秒杀商品页面缓存在 CDN，同样需要和 CDN 服务商临时租借新增的出口带宽。

**用户重复提交**：

首先在秒杀时间之前，秒杀按钮是置灰的。用户点击提交之后作按钮保护，将按钮 disabled 置灰几秒，之后再允许尝试。

**秒杀时间统一**：

秒杀开始的时间需要统一，需要客户端与服务端的秒杀时间相同。可以采用客户端**定时和服务器同步时间**的方式，隔一段时间请求 web 服务的时间。web 服务返回时间的逻辑很简单，但也要考虑到性能问题，如果有很多请求，则需要通过集群的方式，将请求负载平均到集群中各服务上。

## 2.2 后端层面

### 2.2.1 超卖与高并发扣库存

秒杀的情景有两个特点，首先是**高并发的访问**，以及商品可能出现**超卖现象**。这两个问题都可以通过**<font color=red>乐观锁</font>**来解决，同时配合 Redis 与 Kafka 将上述问题解决。从秒杀的业务流程来看，该问题的解决流程如下：

1. 用 Redis 设置 **Token**（即令牌），过滤大量用户；
	- 在 Redis 中，设置与商品数量相同的 Token，抢到 Token 的用户可以继续下单，没抢到 Token 的用户直接返回失败结果，从而过滤大量用户；
2. **乐观锁**设计商品订单库表；
	- 乐观锁的详细介绍，在笔者写的文章[《乐观锁在电商系统中的典型应用》](./乐观锁在电商系统中的典型应用.md)中有详细的介绍说明。
3. 成功抢到的订单通过 Kafka 异步消费，减缓消费速率；
	- 因为秒杀的商品量可能也会比较多，比如 10000 个。这种秒杀量比较大的情况如果没有 Kafka 减缓消费速率，订单直接打到数据库，也可能会出现数据库崩溃的情况。

### 2.2.2 防止用户作弊行为恶意攻击

秒杀一般是定时上架
该功能实现方式很多。不过目前比较好的方式是：提前设定好商品的上架时间，用户可以在前台看到该商品，但是无法点击“立即购买”的按钮。但是需要考虑的是，有人可以绕过前端的限制，直接通过URL的方式发起购买，这就需要在前台商品页面，以及bug页面到后端的数据库，都要进行时钟同步。越在后端控制，安全性越高。

定时秒杀的话，就要避免卖家在秒杀前对商品做编辑带来的不可预期的影响。这种特殊的变更需要多方面评估。一般禁止编辑，如需变更，可以走数据订正多的流程。

前端层的请求拦截，只能拦住小白用户（不过这是99%的用户哟），高端的程序员根本不吃这一套，写个for循环，直接调用你后端的http请求，怎么整？

（1）同一个uid，限制访问频度，做页面缓存，x秒内到达站点层的请求，均返回同一页面

（2）同一个item的查询，例如手机车次，做页面缓存，x秒内到达站点层的请求，均返回同一页面

如此限流，又有99%的流量会被拦截在站点层。 

##4.3 服务层设计

站点层的请求拦截，只能拦住普通程序员，高级黑客，假设他控制了10w台肉鸡（并且假设买票不需要实名认证），这下uid的限制不行了吧？怎么整？

（1）大哥，我是服务层，我清楚的知道小米只有1万部手机，我清楚的知道一列火车只有2000张车票，我透10w个请求去数据库有什么意义呢？对于写请求，做请求队列，每次只透过有限的写请求去数据层，如果均成功再放下一批，如果库存不够则队列里的写请求全部返回“已售完”；

（2）对于读请求，还用说么？cache来抗，不管是memcached还是redis，单机抗个每秒10w应该都是没什么问题的；

### 2.2.3 降级限流，服务熔断