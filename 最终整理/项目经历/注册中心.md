# 注册中心

## 1. 主题和服务怎么支持分布式？

ZK 管理集群 (Cluster Manager)，**管理内容为 war 包级别**。信息在 ZK 的 /CLUSTER/ADDRESS 各节点上；节点上有服务信息，如服务中英文名称、IP、端口、说明描述、版本、类型等。

资源目录管理系统 (ds) 注册服务和主题，主题是 XML 级别，每个主题对应一个主题服务的 subjectConfig 下的 xml 文件。

## 2. 服务的注册与发现

### (1) 业务组的服务注册与发现

AbstractRegisterService # register 注册方法。

1. 主题启动时，RegisterServiceSimple 的 Spring Bean 的 init-method 方法中进行 register() 注册；
2. 读取 subjectConfig, resourceConfig 的所有 xml 文件内容；
3. 对所有主题信息，进行注册 register()，注册过程中进行发布 publish()；发布后会将主题、服务信息存在数据库表中。

### (2) Dubbo 的服务注册与发现

> 参考地址：[《阿里dubbo服务注册原理解析》](https://www.cnblogs.com/linlinismine/p/7814521.html)  
>
> 详细调用过程：[《dubbo服务注册与发现、服务调用过程》](https://www.jianshu.com/p/1ff25f65587c)

ServiceBean#afterSetProperties 中调用了 <code>**com.alibaba.dubbo.config.ServiceConfig#export**</code>方法，主要代码如下：

```java
//如果配置不是local则暴露为远程服务.(配置为local，则表示只暴露本地服务)
if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) {
    if (logger.isInfoEnabled()) {
        logger.info("Export dubbo service " + interfaceClass.getName() + " to url " + url);
    }
    if (registryURLs != null && registryURLs.size() > 0
            && url.getParameter("register", true)) {
        for (URL registryURL : registryURLs) {
            url = url.addParameterIfAbsent("dynamic", registryURL.getParameter("dynamic"));
            URL monitorUrl = loadMonitor(registryURL);
            if (monitorUrl != null) {
                url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());
            }
            if (logger.isInfoEnabled()) {
                logger.info("Register dubbo service " + interfaceClass.getName() + " url " + url + " to registry " + registryURL);
            }
            Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));
            Exporter<?> exporter = protocol.export(invoker);
            exporters.add(exporter);
        }
    } else {
        Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);
        Exporter<?> exporter = protocol.export(invoker);
        exporters.add(exporter);
    }
}
```

整个服务的暴露过程如下图所示：

![img](https://images2017.cnblogs.com/blog/905730/201711/905730-20171110175055856-2054003383.png)

然后再补上一消费者调用提供者的图：

![img](https://images2017.cnblogs.com/blog/905730/201711/905730-20171110175212669-2102453811.png)

下面给出具体某一种协议的实现，假设配的协议是dubbo，注册中心用的是zookeepr。那么代码的调用过程大致是这样：

1. 调用 JavassistProxyFactory 生成一个Invoker；

2. 用com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol#export 方法，进行一个服务的暴露；

3. DubboProtocol#export 方法最终会调用 com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistryFactory#createRegistry；进行一个服务注册；

这时 zookeeper 相应的目录下面就会有对应的内容，这时服务注册就算完成了。

## 3. 负载均衡调度？和 Nginx 的区别？

注册中心负载均衡：**客户端实现**，有随机 (RandomLoadBalance)，IP Hash，一致性 Hash (ConsistentHashLoadBalance)；  

**为什么客户端实现负载均衡？如果用 Nginx 实现负载均衡，应该怎么实现？如果超过了 Nginx 的单机负载均衡极限，应该怎么继续扩容？F5，LVS？**

Nginx 主要作用：扩容、反向代理、负载均衡、网关；

七层（应用层）/四层（传输层）负载均衡模型

## 4. 订单与订阅？为什么广播？

订单：订阅者 + 被订阅者的组合；

- 订阅者包含 IP、端口、传输协议、主机号等信息 (ProtocalInfo)；
- 被订阅者可以理解为 Kafka 的 Topic；

订单的数据存储：

1. 在数据库中存储订单信息，对应的服务为 subMgr；
2. 存储在 kafka 的 topic 中；在这种订阅的使用情景下，需要使用 Kafka 的广播模式；

订阅：

1. 填充订单信息，将订单存入数据库；

2. Kafka 订阅（如果订阅失败，将存入数据库的订单从数据库删除）

   - **<font color=red>订单的分发？</font>**
   - 分发后处理，对订单进行 MD5 编码处理；
   - 从库中获取并删除旧订单；
   - 订单信息保存本地库与本地内存，并异步启动订阅线程，将订单通过 Kafka 发送；
   - 处理订单：每个订单有一个线程池，该线程池不断循环的从订单对应的 topic 队列中拉去信息 (poll(6000))；拉取的信息反序列化后，用观察者模式的形式通知给各订阅了该订单的消息；

## 5. 平时订阅的主题，与 Kafka 是怎么对应的？订单与 Kafka 的物理对应？（topic, partition）

**为什么只有一个 partition？是否可以发布多个？**

发布时回发布一个 topic，发布 topic 的时候可以指定几个 partition，但一方面，多个 partition 适合在不在意处理顺序的情况下使用；另外一方面，业务支撑提供给外界的接口不能指定 partition；

## 6. 订单号与流水号的意义？是否幂等？

不处理幂等问题；对于处理错误的订单，需要业务组将信息存入内存，自行处理；

## 7. 服务是怎么做降级？熔断？限流的？

限流：guava 的 RateLimiter。

