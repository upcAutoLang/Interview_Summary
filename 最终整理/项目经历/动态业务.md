# 一. 动态模板

## 1. 业务简要说明

用户有上下级数据的上报体系，所以需要所有数据是有一套数据标准的，标准由甲方定制。然而在实际使用中，用户反映，一方面我们提供的数据不符合他们实际使用情况的内容，另一方面他们实际需要进行记录的数据有一定的可变性，所以用户提出需要根据他们需要，可以动态制定模板的功能。换句话说，就是类似于动态报表，但又与用户信息紧密结合的业务。所以动态模板业务就有了。

## 2. 业务主线流程

业务主要流程分七步。

### 2.1 前台填写模板信息

数据表信息包含表本身的信息，以及各个字段的信息。表本身的信息，基本就是表的名称。字段的信息，有三个是必填字段，数据时间用来记录填入数据的事件、记录 ID 是 UUID 用作主键记录、数据来源 ID 标识了这条数据的来源单位。此外的字段需要用户的需要进行填充，填充的内容包括数据的类型（字符串、数字、时间、数据源、关联表），是否允许筛选，是否允许排序（筛选和排序即对对应的字段建立索引）。比如今天是**<font color=red>蚂蚁金服</font>**的面试，那么新建的表名称就叫做【蚂蚁金服面试】，里面的字段会有时间类型的面试时间、下拉树类型的面试者、字符串形式的面试结果等字段信息。

### 2.2 后台服务接收模板消息

该步骤是后续过程的预操作，主要为后面的几步做辅助。因为后面几步是要求原子性的，所以用 Kafka 实现了分布式事务。  
前台将用户构建的模板信息传递到后台，后台简单处理后，发送一个**半消息**到 Kafka 的创建动态模板主题中，此时并不提交，等待后面的操作执行完毕后再提交。  
后续的所有 RPC 远程方法调用，都存在**正常调用**和**异常回滚调用**的接口。用一个 CountDownLatch 拦截，需要所有 RPC 远程方法调用都在限定时间内全部正确返回，如果有一个错误，都要调用所有远程 RPC 方法的回滚方法，恢复到方法调用之前的状态。

### 2.3 创建数据表

提交半消息到 Kafka 主题后，开始第一步，创建数据表。通过 RPC 的负载均衡找到一个数据服务节点，调用创建数据表的方法。  

#### 2.3.1 正常调用

数据服务根据传入的动态模板信息，用 FreeMarker 渲染 SQL 的 create 语句，用 Mybatis 打开一个 SqlSession，执行 create 数据库表的语句；

#### 2.3.2 异常调用

用同样的方式，通过 FreeMarker 模板渲染一个 drop 语句，将要创建的动态模板数据表删除。执行过程无视异常（比如不存在该表的异常）。

### 2.4 服务端动态加载类

服务是一个集群，需要对集群中所有服务都进行调用。

#### 2.4.1 正常调用

1. 服务传入动态模板信息，用 FreeMarker 渲染 Java 文件，用系统编译器编译出 .class 文件；
2. 新建一个 ClassLoader，把编译完成的类加载到新的 ClassLoader 中；
3. 修改服务配置信息，比如服务的模板列表中添加该新建的动态模板；
4. 丢弃旧的 ClassLoader，修改指针到新的 ClassLoader；

#### 2.4.2 异常回滚调用

1. 不执行最后一步，即不修改 ClassLoader 的指针；
2. 将该动态模板从服务的模板菜单中删除；

### 2.5 数据服务动态加载类与 Mybatis 映射

数据服务是一个集群，需要对集群中所有数据服务都进行调用。

#### 2.5.1 正常调用

1. 同上一步的 1 - 4，完成类的动态加载；
2. 通过 FreeMarker 模板输入消息内容，动态生成 Mybatis 接口与 XML 文件；
3. 用反射的方式，将 Mybatis 的 Configuration 中重要数据信息清除，然后重新加载，就会把动态生成的 Mybatis 加载到 Mybatis 中；

#### 2.5.2 异常回滚调用

1. 不修改 ClassLoader 的指针；
2. Mapper 的 Configuration 不进行重置；

### 2.6 完成动态模板的创建

上述 3, 4, 5 步中所有集群操作全部完成且成功后，第 2 步中的半消息即可提交位移。如果上述所有集群操作有一个超时或不成功，则再次远程调用所有服务的回滚方法。

### 2.7 远程传输动态模板

可以将新建的动态模板，通过我们集团自己的传输服务传给其他的单位。其他单位的服务受到该动态模板数据后，也开始执行上述的操作。成功后，两个单位就同时拥有了同样的数据模板，接下来就可以执行数据上报操作了。

## 3. 动态模板业务修改字段的实现

### (1) 后端方面

问题所在：如果修改字节码中生成类的字段的话，在调用虚拟机方法 virtualMechine.redefineClasses 时，会抛出异常 "Schema change not implemented"。

### (2) 前端方面

- **作用**：另外，主题服务需要用 JAXB 技术生成 XML，<font color=red>用于网络数据层的前台显示（仅有此作用？）</font>。
- **限制**：
	- 主题端不是我们开发的，他们在生成 XML 的工具使用的是 JAXB，并不是我们经常使用的 DOM4J, XStream 等，所以需要使用他们常用的 JAXB；
	- 需要克服 @XmlSeeAlso 的问题：然而 @XmlSeeAlso 的注解在第一次动态生成 Class 文件的时候就已经生成过了。加载到 ClassLoader 中会出现问题：爆出 "@XmlSeeAlso 已经存在 @XmlSeeAlso" 的错误。克服这个问题的方式，就是重新 new MyClassLoader。
		- 注：@XmlSeeAlso 的作用在后文中。

### (3) 解决方法

解决方法是新建一个 MyClassLoader。  

- 在后端方面，这样绕开了使用同一个 ClassLoader 会令同一个类抛"字段发生改变的异常"的问题；
- 在前端方面，用新的类加载器读取新生成的 Class 数据流，也绕开了前端 @XmlSeeAlso 不能二次生成的问题；

> 如果用户修改了字段（即增删改字段），使用**<font color=red>委托机制，利用 MyClassLoader, HotSwapperClassLoader </font>**判断时间，如果后者的创建时间较之前者更新，则 new MyClassLoader，用新的 ClassLoader 生成新修改字段后的 Class 文件。

### (4) @XmlSeeAlso 的作用

由于主题端代码中有泛型继承的内容，所以由于泛型擦除的特性，JAXB 提供了 @XmlSeeAlso 的 Class 级别注解，用于标注说明该泛型类型应该在 @XmlSeeAlso 的 Class[] 列表中。即 @XmlSeeAlso 是用来记录主题端 DataSet\<T> 的泛型内容。

## 4. 业务并发量与数据量



# 二. 动态汇总统计

## 1. 业务简要说明

前面的动态模板只是负责数据的来源，动态汇总统计业务负责的是对数据的动态统计。这个业务诞生的原因也比较类似。甲方给的统计也是按照一定标准的，实际使用的用户认为标准给的统计内容并不符合他们的期望，所以希望我们有一种动态汇总统计的能力，用于他们的统计、文本导出、数据展现。

## 2. 业务设计

这个项目我负责的是全部设计，以及核心功能的后端实现。

### 2.1 业务需求

首先，我们的业务统计面向的主要是表格，表格统计的内容主要是对每行的数据一列一列或简单或复杂的处理，最后形成一个表格。

- 简单处理方式比如提取字段，无需处理，直接从一条数据中获取对应的字段，结果就是一个数据列；
- 复杂处理方式比如对一条数据的物资信息进行统计，物资信息是数据行对应数据的子表信息，那么就要遍历物资子列表，统计信息串成字符串。

### 2.2 责任链设计

在上面的业务情景的前提下，我采用了类似 Netty 的**责任链**的设计模式，一条 pipeline 处理一列数据，由多个处理单元组成，每个单元都是一个处理方法，可以对数据进行处理。pipeline 的输入为单条数据与一个表达式，对应一个 JSONObject 与汇总规则，输出是 String，对应了一个表格中一个单元格的结果。同时，pipeline 上每个单元的输入输出必须前后匹配。

### 2.3 处理方式

处理的规则是由一个规则字符串组成的，这个规则字符串中包含了数据的处理方式，它的解析是通过 Google 的开源表达式引擎 Aviator 完成的。这个开源表达式引擎允许我们自定义一些处理方法，然后用表达式引擎渲染某个输入的字符串，引擎会尝试把输入字符串与自定义方法匹配，如果匹配，就会执行自定义的方法。用表达式引擎的这种特性，我可以定义一些类似于提取字段、四则运算等功能。每个自定义方法都是 pipeline 上的一个 Handler，这样处理完毕后，输入的 JSONObject 就会处理成一个 String，作为一列数据的结果。  
按照上面的方式，遍历所有行，处理所有列，就得到了一个表格。

### 2.4 性能优化

用户对汇总项进行汇总时，可以按照时间段汇总。界面上通常提供当月、当周、当日，以及其他任意时间段的数据。我们主要是对当月、当周、当日的数据进行缓存。  
由于我们业务的特性，历史数据是肯定不会被修改的，所以当日、当周的数据可以被分为两部分：除去今日的当月 + 今日，除去今日的当周 + 今日。这样两个时间段的历史数据都可以作为长时间缓存，服务设定一个定时任务，夜间定时更新。  
此外今日数据是变动的，所以我们每次数据库更新之后会把缓存删除。后面每次查询数据时，第一个查询数据的请求会获得一个分布式锁，然后查询三页的数据存入缓存，这样也是为了缓解用户的分页查询的数据库压力。

### 2.5 数据模板修改

如果前面所说的动态模板执行了模板的修改，成功之后会发送一个模板被修改的 Kafka 消息。动态汇总统计服务订阅这个消息，并推送到前台页面上，提示有修改内容，由用户自行决定是否处理。
