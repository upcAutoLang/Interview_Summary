# 面试经历

## 一. 11.20 字节跳动一面Java开发，直接挂（耻辱开头……）

1. 介绍主要项目，怎么做的；
   - 本来想简要介绍做的业务，但面试官要求详细介绍，所以二十分钟都在介绍业务；
   - **送命问题：数据量多少？**说了实话，实际使用单表1000—10000级别。导致后面基本上面试官根本不想问问题了……
2. 对 Spring 的理解？
3. 对 AOP 的理解？
4. 讲一下 Java 的静态代理和动态代理



然后就没了，进入问问题环节…… 当然知道已经凉了。面试官说的问题主要在于，在研究所的技术栈还是太落后，说互联网的思路和我们这种人不一样。在提了并没有什么实际性的建议之后，结束面试。  

收获：

1. 第一次面试，终于踏出了这一步；
2. 认识到了自己与一线大互联网公司的差距，待继续努力；
3. 由于面试时的准备方向错误，在数据量方面的成果无心之失直接判了死刑，并没有表达出来真正的性能和准备的内容。以后准备，一定要向**大数据量、优化**等方向考虑！
4. 表达能力太差。【对…… 的理解？】这种问题一抛出来，尝试用浅显易懂的方式

## 二. 12.04 蘑菇街一面高级 Java 开发

1. 介绍主要项目（大概二十五分钟左右）；

   - 经过上一次失败，这次梳理了业务的主线，比较熟练的介绍了业务，依旧花了十五分钟，不过中间穿插了询问项目方面的问题；
   - 询问问题：
     - **(1) 动态模板的数据源从哪儿来？**答：资源目录注册，通过各个数据服务获取；
     - **(2) 增量数据比较多的情况下，数据源怎么处理？**答：一方面，数据源通常都是数量比较固定的内容，由各个业务来封装处理，对于增量数据比较多的情况，使用动态模板的关联表模式；另一方面，数据源数据比较多的时候，通常会使用树状结构，数据服务有通用的懒加载处理方式，不会出现性能瓶颈；
     - **(3) 动态模板怎么做数据的逻辑处理？**答：动态模板只负责数据的记录，关于逻辑处理是另外一个业务，在简历中也有介绍。然后介绍了动态汇总的设计逻辑，大概十分钟。**<font color=red>（说明面试官对做的项目有兴趣，并且我的回答已经有了引导性）</font>**
     - **(4) 如果逻辑处理过程中并没有抛出技术性的异常，而是计算错误的异常（类似于 1+1，结果算出来是 3 的错误），有没有什么处理？（问的是有没有计算监控功能）**答：没有，只是较为严密的关注了技术上的异常，计算上的错误没有处理。如果真的处理了这种问题，需要通过运维人员在配置页面中清除 Redis 缓存。

2. 线程池基础
   - **对于一个普通的线程池，coreSize = 5, maxSize = 10，阻塞队列长度 20，且插入线程是永久执行的，那么不断插入线程，线程池中的数量以及对应的反应如何？**答：该问题只需了解线程池的运作原理即可回答。
   
3. Spring AOP
   - **类内部调用 AOP 问题：a() 方法被 @Around 注解用来输出日志，b() 方法没有 AOP 注解，但 b() 方法内部调用 a() 方法，那么调用 b() 方法会有怎么样的输出？**答：不会有日志输出。因为这是类内部调用，而 AOP 是通过代理进行的，类内部调用不会调用代理类，不走代理所以不会有日志输出。如果想要有日志输出，需要在该类中通过 AopProxy 将代理对象（命名为 proxy）获取，然后在 b() 方法中通过 proxy 调用 a() 方法；

4. 为什么临时决定找工作？答：因为比较熟悉这里的工作，想找挑战。

5. 向面试官提问问题。问了问业务内容，技术栈。

## 三. 12.13 蘑菇街二面高级 Java 开发

整体就是介绍主要项目，时间总共四十分钟左右。

1. 动态模板
   - 动态模板的主线流程已经比较熟练了，该方面流程介绍没有什么问题。
   - 询问问题：
     - **(1) 动态模板的数据源从哪儿来？**答：资源目录注册，通过各个数据服务获取；
     - **(2) 动态模板里面的数据怎么来？**答：用户添加了模板之后，往里面录入数据；
2. 有堆 Dump 和数据库连接池优化经验，怎么做的？
   - 基本就是和之前写的博文[《服务假死问题解决过程实记（二）——C3P0 数据库连接池配置引发的血案》](https://blog.csdn.net/ajianyingxiaoqinghan/article/details/89736359)描述的过程相同，把整体过程叙述了一遍。但依旧建议重新整理一遍，形成稿子。
3. <font color=red>**动态汇总统计**</font>
   - **此次面试的绝对雷区**。在叙述该部分的时候，我说明了该项目是我设计的。但在描述项目的设计理念时，并没有像上次一样描述的很清楚，反而描述卡顿，中间一度难以进行下去。该部分的设计一定要形成稿子，并且熟练表达，否则适得其反。
4. 简历中写了统计的效率优化，具体是怎么做的呢？
   - **两个出发点进行优化。**
   - 第一是粒度，我们有的汇总结果是需要统计多个表的。原本在实现的时候，由于要求赶时间上线，又有性能要求，所以当时同事写的时候，在增删改数据时，我们的数据服务触发了订阅，通知集群中所有服务数据更新的事件，所有服务又分别发起了五个表的查询请求，对查询结果进行处理后存入缓存。也就是说，改一次数据，会导致一个服务的五次查询，如果集群里有十个服务，那么改一次数据就会触发五十次查询。但是从业务的角度来看，改了一个表的数据只需要清除该表的缓存即可，其他四个表的缓存并不需要修改，也就是粒度太粗，所以我第一步是将粒度细化到表的级别。
   - 第二是历史数据。因为我们的业务场景是允许查询时间段内的信息，而业务场景又有限制： 今天之前的历史数据是不能修改的。也就是说我们可以把历史数据作为长时间缓存，今天及其以后的数据作为短期缓存，修改数据只触发短期缓存的更新。
5. 简历上写了使用 ZK 的分布式锁，为什么要选用这种实现方式？使用场景是怎么样的？
   - 业界分布式锁通常情况下是用 Redis 的 setnx 来实现的，但当时我们的 Redis 还没有搭建起来，缓存用的是 Memcache；此外，我们的注册中心基础是 ZK，而 ZK 的瞬时顺序节点是可以实现分布式锁的功能，所以我就使用了。
   - 使用场景：我们的汇总比较麻烦一些，所以进行一次汇总时间相对较长。虽然通常汇总结果都会放到缓存里，但如果某一时间缓存中没有数据，又有大量并发进行汇总结果的查询，那么就会引发穿透。所以一方面我和同事搭建了布隆过滤器，防止缓存穿透的情景。另一方面，大量并发同时查询汇总结果时，由于服务做了负载均衡，所以集群中的服务都会接收到请求，缓存中没有汇总结果，会所有大量服务进行计算。但其实只需要一个服务进行缓存的计算即可，其他服务的计算属于资源浪费行为。所以我对一个需要进行汇总的业务使用了分布式锁，用查询条件作为锁，获取到该锁的服务进行计算，并负责将计算结果置入缓存，其他服务在尝试获取该锁的时候失败，返回一个默认的结果，这样便避免了多余的计算。
6. 有什么需要问面试官的问题？问了问业务内容，技术栈。

## 四. 12.20 蘑菇街三面高级 Java 开发（失败）

共 40 分钟左右；

1. 自我介绍

2. 简历上写有 JVM 优化经历，怎么做的？
	
	- 基本就是和之前写的博文[《服务假死问题解决过程实记（二）——C3P0 数据库连接池配置引发的血案》](https://blog.csdn.net/ajianyingxiaoqinghan/article/details/89736359)，并形成稿子，完成叙述。
	
3. 如果设计一个自动监控系统，如何设计？如何实现？
	- 由于在刚才的 JVM 优化过程，目的是监测某个压测问题，我介绍了一个通过 JVM 检查问题原因的流程。所以面试官提出了该问题。
	- 关于自动监控系统的设计，我了解有 ES, Logstash, Kibana 的开源套件，有用于日志收集和监控，但具体我没有过多了解；
	- 如果是基于我们的系统进行实现的话，应该会基于我们的注册中心开发一个新的新的监控服务。我们的注册中心以 WAR 包的粒度，将对应服务注册到 ZK 集群上。所以新的监控服务设计的基本思想，应该是对所有注册到 ZK 上的服务发送心跳包，收集各服务所在服务器的系统指标、服务运行相关信息；
	- 面试官追问：监控哪些服务器和服务的哪些指标？怎么监控？
		- 答：服务器指标应该监控服务器的 CPU 占用率、内存使用量、网络各状态的连接数、网络带宽；服务的指标应该监控 Heap 堆的容量、单位时间内 GC 次数、各状态线程数量；
		- 具体监控的方法我认为 Java 中应该给出了 API 接口可以获取这些信息，因为之前我之前做的的业务操作日志记录系统中，有 IP 信息的获取记录；当时就是调的 Java 的 API，所以我感觉应该有相似的调用方法；
	
4. 索引如何设计？
	- 是由于我说我们目前业务的日志操作监控系统是把数据存到了数据库中，所以提到了该问题。
	- 我的回答：
	  - 我们构建索引时主要针对几种情况：
	    - 对查询使用较多的字段考虑构建索引；
	    - 可能会比较多使用到筛选、排序的字段；如比较常用的时间类型；
	    - 有下拉树唯一标识性质的 ID 字段；
	- 设计原则见[《数据库篇》](./数据库.md)
	
5. ZK 怎么用的？选举机制？
	- 提到 ZK 是因为我提到我们的服务注册到了注册中心上，注册中心是用 ZK 为基础的；
	- 我的项目中接触到 ZK，主要是我在服务集群计算的时候为了节省计算资源，所以使用 ZK 作分布式锁；此外 ZK 也用来我们注册中心的注册；

6. 互联网的架构了解哪些？
	- 回答了秒杀系统，具体有点忘了。
	- 参考：[《《吊打面试官》系列-秒杀系统设计》](https://juejin.im/post/5dd09f5af265da0be72aacbd)

7. Spring 的思想？代理如何实现？
	- Spring 的思想主要是按照之前写的博文进行描述的：[《“王大锤の非诚勿扰” —— Spring IoC / DI 思想详述》](https://blog.csdn.net/ajianyingxiaoqinghan/article/details/82833828)
	- 代理：[《设计模式篇》](./设计模式.md)

8. 为什么选择使用 SSM 框架？为什么使用 Spring boot？
    - 使用 SSM 框架的原因主要是这是整个业界比较通用的框架，而且也是部门的通用框架；
	- 使用 Spring Boot 的原因是，Spring 和 Spring MVC 有很多配置文件，比较繁琐，而 Spring Boot 将很多配置给集成了进来，使用基于注解的配置方式比较简单方便。
9. 了解的互联网常用的技术栈还有哪些？
    - 除了简历上写的，还提到了 Nginx 用于反向代理和负载均衡；如果到达了 Nginx 的反向代理极限，可以使用 F5, LVS 进一步扩充并发量的支持，但我们的并发量没有到达这种程度，所以没有再向上了解。
10. 秒杀系统中，缓存与数据库的一致性如何保证？库存，网络波动。

## 四. 04.08 京东云一面

共 40 分钟左右。基本问的都是用过什么什么东西，没有什么太多项目和技术上实质上的问题。有意义的问题如下：

1. 为什么用 Springboot 代替 SpringMVC？
2. Redis 有哪几种数据类型？
3. Redis 的缓存过期策略？
4. 创建数据库表时需要注意哪些事项？
5. 数据库连接池有哪些比较重要的参数？
6. 用过哪些线程池？线程池是怎么构造的？

其他面试官没什么问的了，面试官问我有没有什么想展示的。我就向面试官介绍了一下我对上报业务的改造。再然后开始对面试官进行提问，我问了问技术栈、业务做什么、人才培养策略。

## 五. 04.10 京东云二面

共 40 分钟左右，基本属于闲聊性质。

1. 为什么用 Springboot 代替 SpringMVC？
2. 业务上为什么用 Redis？
3. 线程池是怎么构造的？
4. 国企的工作形式？部门构造？
5. 数据量有多少？吹了单表百万 + 千级并发，依旧感觉比较少……
6. 最后已经进入到我的提问环节，提问过程中我提到我们的分布式服务治理框架是自研的，我也参与了其中的工作。虽然在开始的自我介绍中已经有了介绍，但面试官这时候才感到好奇，让我介绍一下自研分布式治理框架的项目，以及我在其中担任的工作。
	- 我的回答：因为服务端与客户端都会往 ZK 上注册，也许各业务使用不当的原因，ZK 上的注册了两万多个连接，会出现 ZK 宕机的情况。虽然本源的解决方式，是应该找各业务组进行说明，让他们转换方式，但这种事情是领导协调才能完成的事情。所以现在我们在 ZK 上封装了一个代理层，用来监听和管理 ZK 连接，如果 ZK 连接的处理比较异常，就对它进行一些权限的限制与管理。
	- 同样的，Redis 我们采用的是比较通用的三主三从集群模式，但是也是为了管理，我们现在在集群之上做了代理，代理的作用是转发，连接 Redis 集群的请求到代理上面，代理转发给 Redis 集群，再把响应返回。
	- 目前代理的并没有做太多功能，但主要目的和我们的 ZK 监控的作用一样，监控异常连接，以及做一些权限处理的功能。
	- 面试官应该是对这个比较好奇，问了问这个团队的情况，大致有多少人，做这个项目的团队有多少人之类的问题。
7. 其他提问：和上一位面试官问的问题相同，技术栈、业务做什么、人才培养策略。

## 六. 04.15 京东云三面

共 22 分钟，纯技术面试。

1. MySQL 中，如果一个表的主键为整形，从 1 加到最大，然后再增，会出现什么情况？
	- 回答：通常没有这样做过，我们都是用 UUID 作为主键，另外我们用的是 Oracle。面试官就此作罢。
2. 一个线程正常运行，正常处理逻辑的过程中，怎么让它正常的停止？
	- 没有 get 到面试官的意思，回答不佳。
3. 如果线上频繁发生 Full GC，怎么处理？
	- 看 GC 日志，MAT 分析 Dump 文件，查出错误后修改业务逻辑；
4. Redis 有哪些内存回收策略？
	- noevictable, LRU, LFU
5. Kafka 怎么保证消息不丢失？（即高可用性问题）
	- 使用副本，leader 宕机，也会使用 follower 已经被同步过去的副本；
6. Kafka 怎么保证消息投递出去？
	- Producer 配置：acks = 1, 0, -1 各自的含义；
7. Kafka 怎么保证消息不被重复消费？
	- 配合 Redis 使用，将消息的 ID 存到 Redis 的 Set 中，每次消费消息时判断 Redis 中是否存在该消息 ID，即实现消息的幂等性；
8. 是否使用过责任链？
	- Netty 中自然会使用到责任链，另外在自己的项目设计中，也用到了责任链的设计模式；
9. ZooKeeper 的选举逻辑；
	- 每个节点投票时，选票中包含 (myId, ZxId, epoch) 信息，每轮投票进行判断，超过节点一半数量后，即可选出结果；
10. 有没有什么要问的问题？
	- 业务做什么？
	- 与阿里云、华为云等有什么优势？区别？
	- 京东云大致的面试流程？

基本所有问题都回答上来了，虽然面试时间短，但比较有信心通过该次面试。

> 05.02 记：过了阿里的简历评估。面试官是用的公司电话，但电话标记被手机标记为广告推销，幸亏显示是浙江杭州的电话，我也和面试官提前预约了，所以才进行了面试。  
> 又回想到有一次北京的一个广告推销电话，给我打了两回电话，每次打电话我就等他先开口，但是十几秒没人说话，我就把他挂了。话说京东三面我面的挺好的，这么长时间不给我联系，不会这个广告推销就是京东四面吧…… 但京东每回面试都不给任何预约，也不算亏。

## 七. 05.02 阿里业务平台事业部支付平台简历评估

共 80 分钟，一半项目面试，一半技术面试。

### 7.1 项目面试

大概整体面试了三十五分钟。

1. 比较自信骄傲的项目介绍一下。
	- 介绍了数据上报的服务，首先介绍服务优化前的实现，然后表述未优化时的问题所在。然后说明优化的方法，为什么这么优化。
2. 刚才项目中提到用户手抖，点了两下，那么怎么保证手抖点的这两下不会重复消费？
	- 首先讲的是解决幂等的方式，两种方式，将消息 ID 放到 Redis 的 Set 中，或者用数据库的主键唯一性。
	- 但是现在这种情况，手抖点了两下，就是发送了两个不同 ID，相同内容的消息。解释了一下，因为不涉及钱的问题，所以整体在业务上问题不大。
	- 后来面试官建议，在点击发送消息的页面渲染时，可以从后台生成一个消息 ID 传递给前台，用户点击发送时，再将这个消息 ID 发送过去，这样就算用户短时间内误操作连续点击，也可以通过这个消息 ID 保证幂等性。

### 7.2 技术面试

大概面试了四十五分钟。

1. Java 8 与 Java 7 相比，比较大的提升有哪些？
	- 提到了 HashMap 与 ConcurrentHashMap 的数据结构优化，以及添加了 G1 垃圾收集器；主要讲了一下 HashMap 1.7 的数据处理逻辑。
2. JVM 的内存结构
	- 简要介绍，堆、方法区、虚拟机栈、本地方法栈、程序计数器、运行时常量池；
3. 堆的内存结构，以及 GC 是如何进行垃圾回收的？
	- 堆主要分为新生代和老年代，新生代存放存活时间比较短的对象，老年代存放存活时间比较长的对象。
	- GC 有几种不同的算法，标记-清除、复制算法（用于新生代）、标记-整理（用于老年代）；
4. 简历上说有 JVM 调优经历，怎么实现的？
	- 两个服务，排查后用堆 Dump，将 Dump 文件放到 MAT 工具中进行分析；
	- 后来面试官建议，这种描述会让面试官理解有误，他们会以为我对 JVM 参数修改后，解决了一些性能问题，但按照我的描述，我是通过 JVM 分析了问题；
5. 刚才项目中提到了用户大量点击的行为，那么如果让你设计一个秒杀系统，如何设计？
	- 首先是前端方面，单位时间点击次数限制，时间的统一；
	- 后台方面，用 Redis 做减库存，记录每次减库存操作的用户信息。同时使用 Lua 脚本进行判断，防止超卖现象。最后对于几千几万个秒杀成功的用户，将这些秒杀成功的请求用 Kafka 缓冲，逐步拉取消息，进行后续的下单、消费等业务逻辑执行。
	- 基本和敖丙的文章思路差不多。
6. 分布式锁知道哪几种？
	- 主要使用过两种，第一种是 Redis 的 setnx 操作，还有一种是 ZooKeeper 的顺序临时节点；
	- 追问：有没有用过数据库实现分布式锁？
		- 您说的应该是类似于使用 select ... for update 指令的行锁来实现分布式锁，用这个语句可以将某些行给锁住，其他的对该行进行操作的语句将会被阻塞，直到 select ... for update 语句将锁释放之后，其他行才能获取对该行的执行权。但我认为这种分布式锁不应该露到数据库层，所以我从来没有想过这种实现。
	- 追问：如果分布式锁锁住之后，忽然之间宕机了，其他线程无法获取到该锁，这种问题如何规避？
		- 所以我后来使用了 set nx ex 指令，Redis 对分布式锁 + 过期时间内部进行了原子化处理；
	- 追问：如果分布式锁被其他服务删掉怎么办？
		- 思考后回答：我认为设置分布式锁，就应该设置一个特殊的 key，这个 key 只有本服务可以获取到，如果被其他服务获取到，那说明这个 Key 设计有问题。（后续和面试官交流，这个问题是他最满意的一个问题，因为这个问题明显是我自己思考后得出的答案，没有死记硬背的痕迹）
7. Dubbo 有哪几层？
	- 回答很不好，有点忘了。需要重新复习相关内容。
8. Java 中哪些地方用到了乐观锁？
	- 回答错误，当时有点懵，回答了 CountDownLatch 和 CyclicBarrier，这个是共享锁的概念；
	- 面试官指出错误后，追问：那知道 AtomicInteger, AtomicBoolean 这些原子类是怎么实现的吗？
		- 使用 CAS (Compare And Set)，讲解了该方法 V, A, B 参数的意义。
		- 面试官随后提出，CAS 本身就是一种乐观锁的实现，我当时也明白过来了。所以这部分还是理解不够深入，虽然理解了 CAS 的意义，但没有意识到它是乐观锁。
9. 看到你有博客和开源项目，其中最近一篇是系统架构师培训，讲一下如果要设计一个项目，你会怎么考虑？
	- 主要是用户需求和技术选型。
		- 首先我会先深入了解用户需求与习惯。梳理用户需求时，可以先画用户交互图与时序图，梳理用户的使用习惯，通过使用习惯可以做出判断，哪些时间用户使用量少，哪些时间用户使用量多，进而对技术选型提供信息。
		- 然后到技术选型阶段，根据用户需求，可以梳理用户更注重哪些？可以对安全性，时效性进行分析后，选择软件的技术框架选择与中间件的选择。基本的核心思想是这样。
	- 追问：你自己的文章里写的是用各种建模方法实现项目的设计，应该从这种方向来回答问题，在实际项目中，是否真的使用过这种建模方式来设计？
		- （被唬愣住了几秒）是使用过的，而且刚才我的回答与我文章里记录的没有矛盾，通过画用户交互图与时序图等流程，可以让架构师更加深入了解用户需求，在了解了需求的基础上，才可以对数据关系、业务流程有更深入的了解，方便下一步的领域建模。我就是按照这种思路，来了解用户需求并技术选型，设计后台结构，最后完成项目的。
10. 为什么想跳槽到阿里？
	- 旧工作已经驾轻就熟，想换一个环境工作；
	- 阿里的业务比较复杂，难度较大，想找一份更有挑战的工作，学习更多东西的工作；

### 7.3 注意问题

1. 回答问题时一定要掌握节奏，不要一问就条件反射的开始回答，要有一个思考时间，条理清楚的回答；
2. 面试时，有一股脑抛出答案，把答案挤出来的毛病，从这里可以体现出，其实有的问题可能并没有那么理解；
3. 有点背诵的感觉，没有加入自己的思考。
	- 面试官感觉答得最好的问题，就是如何避免别人删除分布式锁的问题，因为这个问题是我明显**自己思考**之后的结果；
4. 一面的 P7 比较挑剔，下次面试状态一定要比第一次好，否则一面会非常危险；
5. 五一之后，集团同事就开始正式面试，随时做好准备；

## 八. 05.21 阿里业务平台事业部支付平台一面

总共时长 42 分钟。  

回答问题 30 分钟：

1. 介绍项目。（第一个项目，8 分钟）
2. 项目中介绍了一个自研的分布式治理系统，思路是怎么样的？（4 分钟）
3. 描述一下一次 RPC 调用的详细过程。可以说 Dubbo 的，也可以说简历中的自研分布式治理系统。（8 分钟）
	- 叙述了 Dubbo 的 RPC 调用过程；
	- 中间的追问：Response 到消费端的时候，会分发线程吗？消费端等待服务端的时候，它在干嘛？调用的是哪个方法？sleep 方法吗？
		- 我的回答是，会分发线程。异步调用，线程调用的应该是 wait() 方法；
4. 内存泄漏的原因？
	- 简要说一下 ThreadLocal 的内存泄漏原因；
	- 追问：专业点的术语，可以概括一下吗？GC Roots 链栈对象上有太多强引用的对象，在 GC 的时候不会被回收掉；（长生命周期对象持有短生命周期对象的引用）
5. 业务的分层？看我博客里面写到了架构设计，那么架构思想是怎么样的？
	- 回答不是太好，回去好好回去看一下博客思路。
6. （回答上一个问题中，说到了 DDD）你的 DDD 设计思想是怎么在项目中使用的？
	- 回答很不好，基本上已经忘了，没有复习到。
7. Spring 的两种动态代理的原理？
	- 是实现 Spring AOP 的基本原理。对于接口，Spring 的动态代理基于 JDK 的动态代理，对于类，Spring 的动态代理基于 CGLib 的字节码编辑。
8. NIO 的意义？
	- 叙述 BIO/NIO 的时候，回答不好；

12 分钟提问问题：

1. 支付平台是做什么业务的？
2. Redis, Kafka, Dubbo 之类的中间件，是怎么使用的？
	- 不使用，会使用中间件团队提供的中间件。
3. 怎么学习，怎么培养？
	- 技术方面有很多文档，中间件团队的讲座；
4. 我们只是调用中间件平台的 API 吗？需要了解原理吗？
	- 使用为主，但需要了解。可以很快的排查问题。如果是非常深入的问题，或者需要协助，会找中间件团队的同事协调。
5. 业务方面的话，需要提前学习，提前了解什么吗？
	- 支付系统会有很多文档的沉淀，文档会交接和培训，业务是偏向与集团内部的业务。

## 九. 06.04 阿里业务平台事业部支付平台在线笔试

在约定时间面试官打电话，给我的邮箱里发一个链接，打开链接会进入阿里伯乐的代码评测系统。  
代码评测系统中有一个大编辑框，一个小视频窗口，一个小聊天窗口。编辑框里，面试官和面试者都可以写内容，面试官也可以看面试者的代码编写过程，**时间限制一小时**。我的题目如下：

```text
//评测题目: 无
实现转账系统，给外部系统提供账户开户，充值，转账rpc服务，要求如下，

- 账户类设计：类名：Account，包含属性账号，账户余额，持有人身份证账号
- 开户功能：
  - 入参：开户人身份证账号
  - 功能逻辑：创建对应的Account，并持久化
  - 返回值：账号
  - 要求：一个身份证只允许有一个Account，每个Account的账号唯一
- 充值功能：
  - 入参：账号，充值金额，请求号（请求号唯一）
  - 功能逻辑：将充值金额增加到对应账户的余额中去
  - 返回值：余额
- 转账功能：
  - 入参：转出账号，转入账号，转账金额，请求号（请求号唯一）
  - 功能逻辑：转出账号余额减少，转入账号余额增加
  - 返回值：转出账号余额

- 其他说明
  - 上游系统在调用相关服务超时的情况下，会使用原请求发起重试
  - 充值与充值，转账与转账，充值与转账之间存在并发情况
  - 考虑性能
  - 限定单机提供rpc服务(代码提供rpc接口和实现即可，不用考虑如何发布rpc)，账户持久化上到jvm内存中，不需要使用DB
  - 直接基于jdk编写，不依赖其他框架
```

本来复习的都是 Leetcode 的问题，结果全都没有用到哈哈，最后还是得靠平常基础。  
一小时其实并没有完成全部，中间考虑的时间比较多，只差转账功能的最后一点。最终时间到了的时候，我写的代码如下（没有完成的代码）：

```java
/**
 * 账户类
 */
public class Account {
    // 属性账号
    private String id;
    // 账户余额
    private int money;
    // 身份证账号
    private String idCard;

    // setter, getter...
}

/**
 * 账户操作 RPC 服务接口
 */
public interface AccountService {
    /**
     * 开户功能
     入参：开户人身份证账号
     功能逻辑：创建对应的Account，并持久化
     返回值：账号
     要求：一个身份证只允许有一个Account，每个Account的账号唯一
     */
    String createAccount(String idCard);

    /**
     * 充值功能：
     入参：账号，充值金额，请求号（请求号唯一）
     功能逻辑：将充值金额增加到对应账户的余额中去
     返回值：余额
     */
    int putMoney(String id, int money, String reqId);

    /**
     * 转账功能：
     入参：转出账号，转入账号，转账金额，请求号（请求号唯一）
     功能逻辑：转出账号余额减少，转入账号余额增加
     返回值：转出账号余额
     */
    int transferMoney(String dstId, String srcId, int money, String reqId);
}

/**
 * 账户操作 RPC 服务实现类
 */
public class AccountServiceImpl implements AccountService {
    private AccountRepository accountRepository = new AccountRepository();

    private MoneyService moneyService = new MoneyService();

    /**
     * 开户功能
     入参：开户人身份证账号
     功能逻辑：创建对应的Account，并持久化
     返回值：账号
     要求：一个身份证只允许有一个Account，每个Account的账号唯一

     其他说明
     - 上游系统在调用相关服务超时的情况下，会使用原请求发起重试
     - 充值与充值，转账与转账，充值与转账之间存在并发情况
     - 考虑性能
     - 限定单机提供rpc服务(代码提供rpc接口和实现即可，不用考虑如何发布rpc)，账户持久化上到jvm内存中，不需要使用DB
     - 直接基于jdk编写，不依赖其他框架
     */
    @Override
    public String createAccount(String idCard) {
        Account entity = new Account();
        String id = UUID.randomUUID.toString();
        entity.setId(id);
        entity.setMoney(0);
        entity.setIdCard(idCard);

        moneyService.initAccount(id);
        accountRepository.addAccount(entity);
        return id;
    }

    /**
     * 充值功能：
     入参：账号，充值金额，请求号（请求号唯一）
     功能逻辑：将充值金额增加到对应账户的余额中去
     返回值：余额

     注：充值与充值，转账与转账，充值与转账之间存在并发情况
     */
    @Override
    public int putMoney(String id, int money, String reqId) {
        return moneyService.putMoney(id, money, reqId);
    }

    /**
     * 转账功能：
     入参：转出账号，转入账号，转账金额，请求号（请求号唯一）
     功能逻辑：转出账号余额减少，转入账号余额增加
     返回值：转出账号余额
     */
    @Override
    public int transferMoney(String dstId, String srcId, int money, String reqId) {
        return moneyService.transferMoney(dstId, srcId, money, reqId);
    }
}

/**
 * 账户信息仓库
 */
public class AccountRepository {
    private Map<String, Account> accountInfo = new ConcurrentHashMap<>();

    /**
     * 添加账户
     */
    public void addAccount(Account entity) {
        String id = entity.getId();
        if (id == null) {
            System.out.println("创建账户错误，账户值为空");
            return ;
        }
        accountInfo.put(id, entity);
    }

    public void setAccountInfo (Map<String, Account> accountInfo) {
        this.accountInfo = accountInfo;
    }

    public Map<String, Account> getAccountInfo() {
        return accountInfo;
    }
}

/**
 * 账户金额处理服务
 */
public class MoneyService {
    // 账户金额信息，Key - 账户，Integer - 当前余额
    private Map<String, AtomicInteger> moneyInfo = new ConcurrentHashMap<>();

    // 充值请求 ID 集合，用于幂等判断
    private Set<String> putMoneyRequestSet = new HashSet<>();
    // 转账请求 ID 集合，用于幂等判断
    private Set<String> transferMoneyRequestSet = new HashSet<>();

    // 账号锁，内容为账户 ID，用账户 ID 进行锁操作
    // 如果当前某账户正在执行充值或转账操作，则该 Set 中包含该账户 ID
    private Map<String, ReentrantLock> lockMap = new HashMap<>();

    // 事务锁

    // 初始化账户信息
    public void initAccount(String accountId) {
        if (moneyInfo.containsKey(accountId) {
            moneyInfo.put(accountId, 0);
        }
    }

    /**
     * 充值操作；
     * 返回值：余额
     */
    public int putMoney(String accountId, int money, String requestId) {
        // 幂等判断，是否已经处理过该充值请求
        if (putMoneyRequestSet.contains(requestId)) {
            System.out.println("已处理过该充值操作");
            AtomicInteger aint = moneyInfo.get(accountId);
            return aint.get();
        }
        putMoneyRequestSet.add(requestId);

        // 获取锁，判断当前账户是否正在执行充值操作
        ReentrantLock lock = lockMap.get(accountId);
        if (lock == null) {
            lock = new ReentrantLock();
        } else {
            String msg = String.format("当前账户 [%s] 正在执行充值操作，直接返回", accountId);
            System.out.println(msg);
            AtomicInteger aint = moneyInfo.get(accountId);
            return aint.get();
        }

        // 执行充值逻辑
        try {
            lock.lock(5, TimeUnit.SECOND);

            lockMap.put(accountId, lock);
            // 原子类操作
            AtomicInteger aint = moneyInfo.get(accountId);
            int accountMoney = aint.get();
            int result = acountMoney + money;
            while (aint.compareAndSet(accountMoney, result) {
                accountMoney = aint.get();
                result = acountMoney + money;
            }

            moneyInfo.put(accountId, aint);
        } finally {
            lock.unlock();
        }
        return accountMoney;
    }


    /**
     * 转账功能：
     入参：转出账号，转入账号，转账金额，请求号（请求号唯一）
     功能逻辑：转出账号余额减少，转入账号余额增加
     返回值：转出账号余额
     */
    public int transferMoney(String dstId, String srcId, int money, String reqId) {
        // 幂等判断，是否已经处理过该充值请求
        if (transferMoneyRequestSet.contains(srcId)) {
            System.out.println("已处理过该转账操作");
            return moneyInfo.get(srcId);
        }
        transferMoneyRequestSet.add(requestId);

        // 获取锁，判断当前账户是否正在执行操作
        ReentrantLock srcLock = lockMap.get(srcId);
        if (srcLock == null) {
            srcLock = new ReentrantLock();
        } else {
            String msg = String.format("当前账户 [%s] 正在执行金额操作，直接返回", accountId);
            System.out.println(msg);
            return moneyInfo.get(accountId);
        }

        // 执行转账逻辑
        try {
            srcLock.lock(5, TimeUnit.SECOND);
            // 判断转出账户是否余额是否足够
            AtomicInteger srcAtomicInt = moneyInfo.get(srcId);
            int srcAtomicInt = srcAtomicInt.get();
            if (srcAtomicInt < money) {
                String errorMsg = String.format("账户 [%s] 余额不足 [%d]，转账失败", srcId, money);
                System.out.println(errorMsg);
                return srcAtomicInt;
            }

            // 转出
            int srcResult = srcAtomicInt - money;
            while (aint.compareAndSet(srcAtomicInt, srcResult) {
                accountMoney = aint.get();
                srcResult = acountMoney + money;
            }

            // 转入
            AtomicInteger dstAtomicInt = moneyInfo.get(dstId);
            int dstAtomicInt = dstAtomicInt.get();
            int dstResult = srcAtomicInt + money;
            while (aint.compareAndSet(dstAtomicInt, dstResult) {
                accountMoney = aint.get();
                result = acountMoney + money;
            }

            lockMap.put(accountId, lock);
            int accountMoney = moneyInfo.get(accountId);
            accountMoney += money;
            moneyInfo.put(accountId, accountMoney);
        } finally {
            lock.unlock();
        }
        return -1;
    }
}
```

需要注意的是，代码全程在编辑器上写，不能使用 IDE，所以对操作影响还是不小的。最后时间到，没写完，不过面试官通知明天晚上参加二面。不知道笔试对面试有什么样的影响，目测笔试是面试官观察面试者代码编写习惯、思路的过程，只要思路比较清晰，应该就不会有太大的影响。

## 十. 06.05 阿里业务平台事业部支付平台二面

共一小时五十分钟。主要两大部分，一是对笔试题即转账系统，二是自己选一个做过的项目进行询问。

### 10.1 围绕笔试题的面试

共四十五分钟左右。

1. 昨天的面试题（见前面的问题），有哪些面试点？
	- 回答：首先领域建模，用户系统考虑比较简单，转账系统考虑了原子性的考虑。性能与安全性上，用乐观锁的 AtomicInteger 的 CAS 比较操作，实现充值过程；用请求号解决幂等性问题。
2. 回答中讲到了乐观锁和悲观锁，什么是乐观锁，什么是悲观锁，它们的使用场景是什么？
3. 假设我们有一亿个账户，对于这个账户系统，每秒 QPS 大概有五千（随便举个例子）为了保护账户系统的存储和高并发，怎么设计？
	- 回答：性能上，首先先做服务集群，前端用用 Nginx，把流量摊到各个服务上；服务后面用消息队列 Kafka 缓冲数据。存储上设计需要分表，根据账户的属性，比如身份证号中有省份信息，根据省市进行拆分。
4. 两个场景：充值的功能，某个账户收入非常多，转账存在充值行为。如果分到各个库里了，单个账户并发量非常高，怎么保证充值不能加错，又要保证性能；
	- 回答：首先还是需要将数据用消息队列缓冲。也许需要流水系统，可以把操作记录到流水系统中，变成两个主题，第一个主题向流水中存入数据，第二个主题是充值，充值主题消费流水的消息，实现充值操作。
5. 那么怎么保证流水（本地数据）和发送消息（Kafka 的消息）的一致性？按照我说的场景，已经把充值操作用流水进行了解耦，但再怎么解耦，也会出现问题：向数据库中存储这条流水，和把这条流水的 Kafka 消息发出去，怎么保障这两个操作的一致性？
	- 提示：比如存入了数据，但发消息超时，这样本地数据库产生了一条记录，但没有消息；这种问题怎么解决？
	- 没有回答上来。
6. 新的问题：刚才是一个账户的问题，那么多个账户的转账操作，比如在秒杀活动之后，大量的买家向卖家转账，怎么保证他们转账操作的性能？（跨库，事务，大量转账）
	- 没有回答上来。
	- 追问 1：那么感觉性能瓶颈在哪儿？数据的悲观锁。
	- 追问 2：哪个账户的性能瓶颈更大？转入。
7. 从哪些维度来分析这些问题？
	- 没有回答上来。

### 10.2 自选项目

自己选一个项目，介绍一下背景，遇到什么问题，怎么解决的？我选了我们业务组数据上报业务的优化。  
该部分总共四十五分钟。描述项目使用了十五分钟，叙述了项目中遇到的问题，解决问题的思路。整体上，是从功能实现上来出发描述的。面试官用十分钟的时间表述自己对我叙述业务的理解，十五分钟提出问题。  

1. 使用了异步化之后的收益，解决了什么问题？
	- 答：保证数据的顺序，根据顺序对数据处理。
2. 怎么保证数据的顺序，保证什么顺序？
	- 答：按照接收到数据的时间即报文的到达时间排序。因为我从上游系统收到报文的时候，是没有发送时间的消息的，而且即使是跨系统跨网络，我们也有一个跨系统的服务，保证各个系统之间的时间一致性，所以即使跨系统到达时间是准确的。
3. 刚刚我介绍的项目中为了把问题解耦，分为了一个正常的消费主题，还有一个用于处理异常情况的重试主题，这个是为了解决什么问题？
	- 答：重试主题的设置，主要是考虑到我们业务组未来的优化工作。后续优化我们的业务过程中，如果消费过程有异常情况出现，就把错误消息包装成重试信息，投入到这个重试主题中，就是把重试主题作为业务组的一个全局主题。
4. 刚才的叙述中，提到使用了 Redis，解决了什么问题呢？（严重怀疑面试官没有听我讲……）
	- 解决消费幂等性问题；
	- 实现重试间隔时间不同的问题；异常情况要进行重试，对于必然异常（代码实现逻辑问题，或者报文有问题）或者偶然异常（网络抖动），重试的价值是不一样的，重试次数越多，价值越低，所以我的设计中越往后的重试，间隔时间越长。而 Kafka 的拉取是定时的，所以我把重试消息从 Kafka 中拉取出来转到 Redis 中，把下一次重试时间存入到 Redis 的 ZSet 中，定时拉取 ZSet 中的内容，实现多次重试使用不同间隔时间的效果。
5. 如果把重试队列作为全局的主题，那么有的业务要求时间比较紧，可能需要一小时之内就要重试完，有的业务要求时间不着急，一星期之后再重试也没关系，那么按照我描述的情况，这一个重试队列怎么实现这种差异性？
	- 没有考虑到这个问题，因为业务场景中没有这种需求。如果真的涉及到重要性的考虑，可能会多添加几个主题。
	- 追问：业务诉求变化是很快的，这样扩展性太差了，怎么解决扩展性问题？
	- 答：扩展我们的重试消息内容。

### 10.3 向面试官提问

1. 我使用的是开源的技术栈，阿里不管是消息队列，缓存，框架等都有自己的技术栈，如果进入阿里工作，对接是否有困难？
	- 答：没有什么困难。阿里内部的技术栈有很多也是根据市面上开源技术栈改进的，与开源技术比，实现上有点区别，而且加入了一些阿里要解决问题的特性，但是技术的思想没有什么区别，要解决的问题都是一样的。
2. 支付平台是对谁负责？
	- 答：最底层做运维，做服务器等（阿里云），再往上走，异构系统之间的中间件、存储、消息等，解决分布式系统下的通信问题；再往上走，是业务中台；再往上走，是业务前台，淘宝天猫盒马鲜生等。支付平台是业务中间件，对淘宝天猫等业务前台的功能进行高度抽象，保证高度灵活性，高稳定性、高性能。
	- 对中台同事的要求：业务上一定要对电商业务非常熟悉，这样可以在多变的业务中找到本质；技术上要对工具箱特性非常熟悉，要找到最合适的工具箱，解决现有的问题。
3. 支付平台与蚂蚁金服、支付宝有什么样的关系？
	- 阿里的支付方式已经不是纯支付宝了，支付宝只是一个业务功能集合；
	- 对企业而言有大额支付，支付宝不能满足；
	- 支付方式很多，多次支付、组合支付等；
4. 对于刚才我项目中的批评意见，有什么样的建议？如重试队列扩展性。
	- 需要有一套面向业务的配置机制，要抽象出一套配置标准出来，根据配置确定不同的重试策略。
5. 你们在遇到很多业务问题时是怎么解决的？是一次次的迭代，有什么问题就解决什么问题，还是讨论出一个完美的模型解决所有问题？
	- 作为架构师，要从时间的角度看问题，不要老是局限与现在的业务场景。以终为始，算清现在的资源，瞄准最终的目标，向目标一步步前进。
	- 目标不要基于眼前的问题，否则会出现跟着问题跑的情况，出现下一次的问题把上一次解决问题的方式给推翻了的情况，这样有很大问题。
	- 做架构要做平衡，平衡业务复杂度与实现难度，平衡时间和资源。要规划长期、中期、短期的打法。
	- 背后问题的根本原因是什么？不要只单纯找到一个问题，还要深入多看几步，从偶然的问题中找到其中的必然联系性。

> 注：
> 
> 1. 面试官更关注的是一个问题的核心矛盾在哪儿，怎么解决这个矛盾的？遇到这个问题，你想了几步？面试官并不关心各种技术的具体实现细节，因为实现只是很简单的实现手段而已，我们的目的是解决问题，那么就需要找到问题，分析问题，深入思考问题，最后才是解决问题。  
> 2. 不可能设计出来一个完美的解决所有问题的系统，这样容易过度设计。但是面试官提出了这个问题，可以说现在的业务没有这种诉求，可以说资源不足不能解决这个问题，可以说不存在这个问题并给出原因，但不能说没有想过这个问题。

## 十一. 06.05 阿里业务平台事业部支付平台三面

总共九十五分钟左右。

### 11.1 跳槽原因

### 11.2 设计场景

该过程大约 50 分钟。

1. 场景：设计一个 RPC 框架，有哪些挑战点？
	- 介绍了一下我们自研的分布式服务治理系统，介绍了为什么实现这个系统，结构是怎么样的，分层是怎么做的，与 Dubbo 的相同与不同，我们这样实现的优缺点。
	- 追问：客户端是一个接口，怎么实现不同语言（C++, Java, Python）的接口？
		- 答：使用 Google proto 的方式生成 proto 文件，生成不同语言的接口；
	- 追问：客户端消费流程？
		- 答：因为这个流程和 Dubbo 的思想是完全一样的，所以描述了 Dubbo 一次远程调用的流程；
	- 追问：负载均衡是怎么做的？
		- 答：权重、IP Hash、一致性 Hash；
2. 场景：服务端在不同机房里面，策略：优先调用同机房，如果同机房不存在服务提供者，根据用户 ID 做负载均衡调用其他机房的服务。这样的策略怎么实现？
	- 答：两个地方：首先在 ZK 节点注册的时候，提供机房信息，这样在拉取所有可用服务列表中，包含机房信息；另外对于这种新的负载均衡策略，同时需要实现负载均衡的接口，然后实现上述的策略内容；
	- 追问：应用知道哪个机房，这种很难实现；
		- 答：那也许也可以根据 IP 筛选。如果当前服务调用者想要调用本机房的服务提供者，那它们的 IP 应该是比较类似的，头几位相同，其他机房的差别应该比较大，通过这样的特性，筛选出本机房与其他机房。筛选出其他机房之后，根据用户 ID 对其他机房进行一个一致性 Hash，然后进行远程调用；
	- 追问：如果这个服务是一个写操作，某个集群可能网络有问题，需要把请求移交到其他机房，这个情况怎么办？
		- 容错策略？
	- 追问：一致性 Hash 与普通 Hash 有什么区别？
		- 把请求分散到 Hash 环上，优化 Hash 冲突。
	- 如果使用普通 Hash，怎么不能解决 Hash 冲突？
		- 没有回答上来。
3. 场景：如果切了不同的集群（即不同的机房），那么重复下了订单，可能会出现重复数据、冲突的情况，这种情况有什么思路？
	- 只对重复消费有解决方案，用 Redis Set 解决；通常我们只有单机房，所以多机房没有考虑过；
4. 场景：假设单集群，两个用户做支付操作，分别 RPC 调用后的两个服务，需要一系列业务检查，检查后才能进行支付。首先怎么保证一致性检查？如何避免重复支付的问题？
	- 可以先用分布式锁，确保一个请求使用；
	- 追问：具体把场景限定一下，两个用户都只有两百的余额，都进行两次操作，第一次支付一百，第二次支付两百。这样的场景，服务端的调用序列是什么样子的？
		- 答：先用分布式锁锁住，有超时时间。在超时时间之内，把它包装成消息投入到消息队列中，然后释放分布式锁。之后另外一个线程会获取到分布式锁，然后就依然把消息投入到消息队列中，这样就保证了两个过程的顺序。
	- 追问：这样同一个用户的操作会串行化，对吞吐量会有影响吗？
		- 答：按照我这种设计思路，是会有吞吐量影响的。
	- 追问：回到之前的问题，其实就算包装投递到消息队列，也可能会有超时的，感觉哪些因素会导致超时？
		- 答：投递网络原因。（面试官补充：线程的切换，导致时间延迟）
	- 追问：锁超时，这个线程会是什么状态？
		- 答：如果是分布式锁，锁超时，这个线程依旧是 RUNNING；如果不是分布式锁，这个线程会进入中断，中断后线程结束。
	- 面试官补充：如果一个锁超时，一定是要进入中断状态，如果不是这样，那么这个锁一定是有问题的。所以超时之后，应该进入异常状态，所以这个问题的本质是回滚问题，状态异常之后，如何把异常回滚回来，因为这个操作一定不会继续了。

### 11.3 自述项目

项目讲的与上一个面试官基本相同，表述自己项目的情况、问题、如何设计解决问题的方案，以及解决问题的方式。共三十分钟。

其中与技术相关的问题：

- 如果 Kafka 的消息回滚，会怎么样？
	- 消息提交到 Broker 端，如果正常提交，那么会把位移也提交，消费者就可以消费到消息；如果回滚，那么位移就不会提交，消费者就不能消费到这一条消息。

### 11.4 问题

1. 首先两个用户消费的问题，应该怎么解决？
	- 伏笔：锁超时会怎么样的形态？问的点是怎么保证回滚掉，保证并发？或者乐观锁、悲观锁回答。分布式锁不一定都可以，所以应该使用乐观锁、悲观锁实现。
2. 这是交叉面试吗？
	- 这是最后一次技术面试，也是一次交叉面试。
	- 整体表现不是太好。面试的表达其实很清楚，但在面对一些比较挑战性的问题，回答的很一般。所以需要和其他同事对接一下，讨论后续是否进入下一轮大老板的面试。