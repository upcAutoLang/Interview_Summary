# 一. JVM 调优，工作中怎么用，GC 算法和回收策略有哪些

**JVM 调优如何使用**：

笔者首先会使用到的工具：

- java 自带工具：JVisualVM 用于监控，jstack 查看线程状态，jmap 用于堆 dump；
- Memory Analyser：载入堆 dump 文件，进行分析。

1. 在项目启动的时候，加入 -XX:+PrintGCDetails 参数，可以观察 GC 的频率。观察 GC 频率可以判断 GC 频率是否正常（主要是针对 Full GC）。如果不正常，就可以 GC 日志，并且针对 GC 的频率进行原因的猜测。
2. 如果有堆 Dump 文件，则可以观察内存中占据最大空间的对象是什么，如果有特定的某些对象占据了太大的对象，则需要重新考虑是否有可以优化的空间？（比如 C3P0 连接池资源过大，太多的 HashMap 节点占据过大内存等）

GC 回收算法：

1. **标记-清除算法**：对需要回收的对象进行标记，然后清除；
2. **复制算法**：将内存区域分为两部分 A, B 区域，发生 GC 时，将 B 区域的所有内容复制到 A 区域，然后清除 B 区域所有内容。发生第二次 GC 时反过来。
	- 适用于朝生夕死对象较多的情况下；
	- 在实际使用时 (如 Parallel Scavange 收集器)，多数情况下只在两块小区域中进行复制操作，这两块小区域通常是在新生代中。新生代分为三部分：Eden + Survivor * 2 (To Survivor, From Survivor)，三者比例通常为 8:1:1。通常如果发生 minor GC 时，将 Eden + Survivor1 的存活的对象全部拷贝到 Survivor2 中，然后将 Eden 和 Survivor1 的全部对象清除。
3. **标记-整理算法**：将需要回收的对象进行标记并清除，然后内存碰撞，所有对象的内存移到一一端。
4. **分代回收算法**：垃圾收集器大多都是只针对新生代或者老年代，所以商用的垃圾收集器一般都会分别针对新生代与老年代，用不同的分代回收算法进行垃圾回收。

**GC 回收策略**：

有几种不同的垃圾收集器，不同收集器各自有各自的收集对象以及收集策略；

1. **Serial** + **Serial Old** 收集器：两者都是串行收集器；Serial 收集器用于新生代的 Minor GC，单线程的 STW GC；Serial Old 收集器用于旧生代，单线程的 STW Full GC；
2. **ParNew** 收集器：Serial 收集器的多线程版本，用于新生代的 GC；
3. **Parallel Scavenge** + **Parallel Old** 收集器：两者都是并行收集器，且都是强调 GC 时间的垃圾收集器。可以通过设置垃圾收集的比率 (程序时间 / (程序时间 + GC 时间))，或者 GC 最大时间，来保障 GC 时间不会过长。但这样也牺牲了新生代空间大小，以及吞吐量大小。
	- Parallel Scavenge: 针对新生代，使用复制算法。
	- Parallel Old: 针对旧生代，使用标记-整理算法。
4. **CMS 收集器**：用于旧生代，强调最短回收时间，使用标记-清除算法。
	- 步骤：
		- (1) 初始标记：标记 GC Roots 直接关联的对象；
		- (2) 并发标记：标记 GC Roots 链上的所有对象，时间最长；
		- (3) 重新标记：标记在并发标记过程中产生的对象，时间不长；
		- (4) 并发清除：对所有被标记的对象进行并行的回收（使用标记-清除算法）；
	- 缺点在于使用了标记-清除算法，容易在内存空间中产生碎片。
5. **G1 收集器**，是一种新式的收集器，对旧生代、新生代没有明确的区分对待，因为它将堆内存换分为若干个 Region，旧生代和新生代与之前的定义不同，物理上不再隔离。标记清除的步骤和 CMS 收集器相似。

**GC 分配内存策略**：

1. 给对象分配内存时，首先优先分配到 Eden 区；
2. 对于比较大的对象 (比如较长的 String 或者数组)，可能会直接进入旧生代。在虚拟机参数中可以设置该参数 -XX:PertenureSize，大于该值的对象便直接进入旧生代。
3. 对于年龄比较大的对象，即经过了多次 minor GC 的对象，会进入旧生代。虚拟机参数 -XX:MaxTenuringThreshold 设置该值，默认值为 1；
4. 并非所有对象年龄都必须达到 MaxTenuringThreshold 值才会晋升老年代，虚拟机会针对根据对象年龄，以及对象的大小，动态的判定是否可以直接进入老年代。Survivor 空间中相同年龄所有对象的大小之和**大于 Survivor 空间的一半，年龄大于或等于该年龄的对象**可以直接进入旧生代；
5. **分配担保策略**：在进行 Minor GC 之前，判断旧生代可用空间是否大于新生代中所有对象大小之和；如果是，则这次 Minor GC 是安全的；如果不是，则需要根据虚拟机参数 HandlePromotionFailure 值，判断是否允许担保失败。如果该值为是，判断老年代可用空间是否大于一个经验值，如果大于，则尝试一次 MinorGC，如果小于，则进行 Full GC。

> 注：GC 机制见下。

# 二. GC 机制

GC 的机制是什么？垃圾回收器的基本原理是什么？是否可以立即回收内存？怎么样主动的通知 JVM 进行垃圾回收？

GC 的目标，是在 GC Root 链之外的所有对象。GC Root 对象如下：

- <font color=red>**被 JVM 栈引用的所有对象**</font>；
- 方法区中，类静态引用的对象；
- 本地方法中静态引用的对象；
- 方法区中常量引用的对象；

引用的区分：

- **强引用**：类似于 new Object()，无论如何都不会被回收，即使 OOM 异常；
- **软引用**：JVM 内存不够的时候就会回收；
- **弱引用**：只要 GC 就会回收 (WeakHashMap 与其有关)
- **虚引用**：没什么卵用，摆设一个而已

对于方法区，类很少会被回收，或者说类被回收的条件很苛刻：

1. 该类不存在任何实例对象；
2. 该类的 ClassLoader 已经被回收；
3. 没有任何地方调用该类的反射；

> 注：垃圾回收基本原理见前面的 GC 算法原理；

立即回收内存？不一定。

主动通知 JVM 进行垃圾回收：System.gc();

# 三. 类加载机制、类加载器

> 参考地址：  
>
> [《类加载机制-深入理解jvm》](https://www.jianshu.com/p/3556a6cca7e5)  
>
> [《Java Class文件格式、常量池项目的类型、表的结构》](https://blog.csdn.net/m0_37701628/article/details/86684589)  

## 3.1 类的加载过程

Java 类的加载过程主要分为五步：**加载**、**验证**、**准备**、**解析**、**初始化**。其中验证、准备、解析可以合称为**连接**。此外，这五步的顺序并不是完全固定的，比如为了支持动态绑定，解析的过程可以放在初始化之后。类的加载过程如下图所示：

![类加载过程](https://upload-images.jianshu.io/upload_images/13202633-3cb11d1712a9efc9.png?imageMogr2/auto-orient/strip|imageView2/2/w/739/format/webp)

### 3.1.1 加载

加载过程主要做三件事情：

1. 根据全类名获取 **\*.class** 文件的路径，通过二进制流读入 JVM 的方法区；
2. 在方法区中将该字节流转为方法区的运行时数据结构；
3. 在堆中生成代表该类的 **java.lang.Class** 对象，Class 对象的实例作为访问**方法区中运行时数据结构的访问入口**；

### 3.1.2 校验

校验阶段主要确保 Class 文件字节流中的内容不会复合当前 JVM 的规范，不会危害到 JVM 运行时的安全。主要验证的有**文件格式、元数据、字节码、符号引用**。

### 3.1.3 准备

准备阶段主要是将为类变量分配内存，并初始化为默认值。以下面的片段为例：

```java
public static int value = 111;
```

需要注意的是，在准备阶段对于 int 类型，**初始默认值为 0** 而不是 111。同样的，其他基本类型的初始默认值都是该基本类型的默认值（如 double 的 0.0）。将 value 赋值为 111 的操作在初始化的步骤（即 clinit 方法）中进行。

### 3.1.4 解析

解析是将**符号引用**转换为**直接引用**的过程。

- **符号引用**：一组用于标识类型的符号，符合 Java 虚拟机规范的常量表，例如其中一项**常量池项目类型**如下图所示；
- **直接引用**：在内存中能够唯一标识对象的引用。可以是内存指针、偏移量、或者是能间接定位到目标的句柄等。

![常量池项目类型](https://img-blog.csdnimg.cn/20190129002542214.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NzAxNjI4,size_16,color_FFFFFF,t_70)

### 3.1.5 初始化

执行类构建方法 **clinit** 的过程。clinit 方法由**所有类变量的赋值动作**和**静态语句块 static{}** 合并而来，这其中也包含了父类的 clinit 方法（类变量赋值动作与父类的静态语句块），同时在执行一个类的 clinit 方法时，也会通过递归方式保证其**父类的 clinit 方法先被调用**。

此外对于初始化阶段，只有几种情况才会要求类立刻执行 clinit 方法：

1. **new**：new 关键字某个未被初始化的类；
2. **父类**：初始化某子类时，父类未被初始化，则先初始化父类；
3. **反射**：通过反射调用某个未初始化的类；
4. **main 方法所在类**；

## 3.2 类加载器





ClassLoader 中有一个 ClassLoader parent，记录其父类加载器。根类加载器 bootstrap ClassLoader 是最顶层的 ClassLoader，没有父类加载器。类加载器的加载范围不同，如果子类加载器想要加载父类加载器已经加载的类，可以同构双亲委派模型机制，直接访问父类加载器已经加载的类。但是有的时候父类加载器也需要加载子类加载器的 Class，这时候就需要打破双亲委派机制模型，主要方式是使用 Thread 类里的线程上下文类加载器的方法 setContextClassLoader。

# 四. 说说对JVM的理解？

# 五. JVM的内存结构，哪些是共享的，哪些是线程私有的？ Java虚拟机里堆栈分别存放什么？

# 六. Java的类加载在哪些情况下会触发？

《深入 Java 虚拟机》P210

- new 指令
- 调用到类的 static 内容
- 反射调用
- 初始化时，如果发现父类没有初始化，则对其进行初始化

# 七. 聊一聊类加载的过程？

# 八. 频繁老年代回收怎么分析和解决？

帖子回复：

1. full GC 频繁回收 是不是 你分配的 年轻代  内存空间不够 导致要回收老年的堆来释放内存
2. 你说的是其中的一个原因，不过后来多调试了几次，发现了永久代空间太小导致了full gc的执行更频繁。在网上找到了导致full gc的执行的因素：
	- 年轻代空间不足
	- per Gen（永久代）空间满
	- CMS GC时出现promotion failed和concurrent mode failure
	- 统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间等
3. 个人觉得，优化手段已经可以了，如果效果不明显，不妨看看业务代码是不是有自己的问题。使用工具抓一下内存，分析一下，哪些对象是最多的，是否合理。jvm优化也有极限，核心问题还是代码质量。
4. JVM调优肯定得看gc log，然后针对性分析、调优。没有通用的、一劳永逸的方案。
5. 我个人认为在项目基本完成后先监控jvm，进行内存和cpu占用率等等的分析会更快发现优化的地方
	- 在开发中为了及时交付不能不在代码质量上做一些牺牲；
	- 团队开发，难免会有良莠不齐的状况导致了整体质量的下降；
	- 在开发一段时间后，囿于个人代码的习惯等等原因很难发现优化的地方
6. Full GC本身是好的，可以清除老年代的垃圾，但是如果Full GC发生的频率高了，就会影响性能，同时意味着系统内存分配机制出现问题。
	- 因为Full GC本身执行时间较长（甚至超过1秒），而且除非采用G1 GC，否则其它的GC方式都会或多或少挂起所有线程执行（Stop-the-world），如果Full GC频繁发生，系统被挂起的次数就会增加，响应时间就会变慢。
	- 同时，Full GC频繁发生，意味着你的内存分配机制存在问题，也许是内存泄露，有大量内存垃圾不断在老年代产生；也许是你的大对象（缓存）过多；也有可能是你的参数设置不好，minor GC清理不掉内存，导致每次minor GC都会触发Full GC；还有可能是你的老年代大小参数设置错误，老年代过小等等原因
