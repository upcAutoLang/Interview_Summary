# 一、Java篇

## 1.JVM部分

###1.1 JAVA垃圾回收机制
###1.2 JAVA垃圾回收器种类与区别
### 1.3 JAVA类加载机

主要的三个雷加载器有根类加载器（bootstrap）、扩展类加载器（ext）、系统类加载器（对应 classpath 路径），从前到后依次为父子关系。某些框架级别的源码会自定义类加载器，它们属于系统类加载器的子类。

类加载器 ClassLoader 源码中，类变量定义有 ClassLoader parent，记录当前类加载器的父类加载器。如果 parent == null，则当前类加载器为根类加载器。

Thread 中有类变量 contextClassLoader，即线程上下文类加载器。用于打破线程的父加载机制：使得父类加载器可以访问子类加载器的 class。

###1.4 JVM性能调优
###1.5 JAVA字节码结构

### 1.6 JVM内存模型

JVM 内存模型是一个虚拟模型，无论是堆内存还是栈内存，都是在主内存中。  
每个线程都有自己的工作内存。对于共享变量，每个线程从主内存中读取该变量，存入该内存自己的工作内存中。对共享变量进行修改时，首先修改该线程工作内存中的值，然后再将工作内存中的值拷贝到主内存中。

###1.7 JIT编译器
##2.并发部分
###2.1 ThreadLocal原理以及内存泄漏
###2.2 JAVA线程模型
###2.3 CountDownLatch和CycleBarrier的原理和区别
###2.4 AQS原理
###2.5 CAS原理
###2.6 JAVA锁类型
###2.7 Java线程池原理以及参数最优化配置
###2.8 Java自旋锁

##3.JAVA基础部分
###3.1 HashMap、LinkedHashMap、TreeMap、ConcurrentHashMap等原理

#### 3.1.1 HashMap

单个节点的结构为 Node\<K, V>，类似于 Entry\<K, V>。

JDK 8 之后，采用数组 + 链表 / 数组 + 红黑树的结构。整个结构为：

```java
transient Node<K, V>[] table;
```

对 Key 进行 Hash 计算，计算出的结果作为 Node 数组的 index 值，在该 index 位置后添加 Node。对于某 index 位置后面接的 Node 数量：

- Node 在 8 个以下：使用链表形式存储；
- Node 在 8 个及以上：使用红黑树形式存储；


###3.2 ArrayList、LinkedList、CopyOnWriteList等原理
###3.3 几种阻塞队列
###3.4 Thread、Runnable与Callable的区别
###3.5 如何理解Future模式
###3.6 几种IO模型(BIO、NIO、AIO)
###3.7 XML部分

## 4 Spring篇
### 4.1 IOC 原理

与常规的应用程序控制对象相反，IoC 容器（Spring 容器）控制应用程序，控制对象本身的创建、实例化与依赖关系。控制反转是指对象的创建权与控制权都从开发者转移到了 Spring IoC 容器上，即从我们自己在 A 对象中 new B 对象的方式，变为了首先 new A, new B，然后通过 IoC 容器注入依赖关系。

###4.2 AOP原理
###4.3 Bean创建方式与过程以及生命周期(注意循环依赖)
###4.4 Autowired和@Resource区别
###4.5 FactoryBean的原理
###4.6 Spring事务机制(事务的ACID，事务的级别以及传播性)
###4.7 Spring事件机制
###4.8 Spring MVC接收请求-处理请求-响应请求的全过程

* Spring MVC如何映射请求
* 消息转换器
* 参数验证与绑定
* 视图解析器

###4.9 Spring MVC如何实现请求异步化？原理是什么？

##5 Spring Boot
###5.1 Spring Boot启动方式与启动原理
###5.2 Spring自动配置原理(spring-factories.properties)
###5.3 常用注解如@Import、@ImportSelector、@Profile、@ConditionalOnClass、@ConditionalOnBean等
###5.4 为何不需要web.xml
###5.5 怎么样实现一个自己的Spring Boot Starter
###5.6 Spring Boot热部署

##6 用户安全
###6.1 Spring Security
###6.2 Shiro
###6.3 JWT、Session+Cookie以及Session同步
###6.4 单点登录原理

##7 RPC相关
###7.1 几种RPC框架的对比(如Dubbo、gRPC、Thrift等)
###7.2 常用的序列化技术(如Protobuf以及Hessian等)
###7.3 gRPC详细原理(服务端、客户端以及通信协议等)
###7.4 Http2.0相关


##8 数据库连接池
###8.1 为何需要连接池
###8.2 连接池常用参数设置
###8.3 连接池原理
###8.4 常见的连接池有哪些？如何比较？
###8.5 多数据源怎么实现？

##9 Mybatis相关
###9.1 SqlSession与SqlSessionFactory
###9.2 ResultMap
###9.3 SqlMapping
###9.4 Statement
###9.5 如何实现Mybatis插件？插件原理是什么？
###9.6 mybatis配置
###9.7 #{}和${}相关
###9.8 Mybatis类型转换(TypeHandler)
###9.9 Mybatis的Executor有哪些

##10 MQ相关
###10.1 几种常用的MQ对比(RabbitMq、Kafka、JMS等)
###10.2 Kafka的IO模型
###10.3 Kafka的Topic与Partition
###10.4 Kafka消息生产者
###10.5 Kafka消费组与消费者
###10.6 Kafka如何保证消息的可靠性
###10.7 Kafka如何保证高可用
###10.8 MQ如果遇到消息积压怎么办
###10.9 Kafka与Zookeeper
###10.10 Kafka典型使用场景
###10.11 Kafka高可用、低延迟、高吞吐量特点
###10.12 Kafka如何保证消息不丢失

##11 Redis相关
###11.1 几种常用的缓存介绍(Memcache、Redis等)
###11.2 Redis五种数据结构
###11.3 Redis持久化(RDB和AOF)
###11.4 Redis事件
###11.5 Redis服务器搭建
###11.6 Redis集群搭建与Master选举
###11.7 Redis Sentinel
###11.8 Redis缓存穿透与雪崩
###11.9 Redis Pipeline
###11.10 假定Redis有10亿个Key，线上如何获取这10亿个key?
###11.11 Redis主从复制如何进行？
###11.12 能否用Redis做消息队列？如何保证消息被多个消费者消费？
###11.13 能否用Redis做分布式锁？

##12 Zookeeper相关
###12.1 CAP原理与Paxos原理？
###12.2 何为分布式一致性？如何保证？
###12.3 Zookeeper如何保证事务的顺序性？
###12.4 Zookeeper的网络IO模型
###12.5 Zookeeper的节点类型？有何区别？
###12.6 Zookeeper的权限机制
###12.7 Zookeeper的Watcher机制？Watcher是永久的还是一次性的？
###12.8 Zookeeper的选举过程
###12.9 Zookeeper是否会自己动清理日志？如何清理？
###12.10 客户端如何正确处理ConnectionLoss(连接断开)与SessionExpired(Session过期)两类连接异常？
###12.11 客户端对ServerList的轮询机制


##13 Web容器相关
###13.1 如何优化Tomcat连接参数
###13.2 Context、Engine、Host、Connector之间的联系
###13.3 Tomcat启动机制
###13.4 Tomcat webapps之间如何设置启动顺序
###13.5 BIO、NIO、APR几种Connector之间的区别
###13.6 Tomcat类加载机制？如何理解WebAppContextLoader？

##14 数据库相关
###14.1 数据库索引
 * 为何要建立索引
 * 索引数据结构
 * 索引类型
 * 索引失效
 * 如何优化索引

### 14.2 如何优化SQL查询
### 14.3 数据库事务
### 14.4 表锁与行锁
### 14.5 慢查询
### 14.6 Mysql的InnoDB与MyISAM存储引擎对比
### 14.7 Mysql的Binlog
### 14.8 内存泄漏
### 14.9 视图与游标
### 14.10 Truncate与DELETE


